#coding:utf-8

"""
ID:          transactions.read-consist-sttm-restart-max-limit
TITLE:       READ CONSISTENCY. Maximal number of statement-level restarts must be 10.
DESCRIPTION:
  Initial article for reading:
      https://asktom.oracle.com/pls/asktom/f?p=100:11:::::P11_QUESTION_ID:11504247549852
      Note on terms which are used there: "BLOCKER", "LONG" and "FIRSTLAST" - their names are slightly changed here
      to: LOCKER-1, WORKER and LOCKER-2 respectively.

      See also: doc/README.read_consistency.md
      Letter from Vlad: 15.09.2020 20:04 // subj "read consistency // addi test(s)"

      ::: NB :::
      This test uses script %FBT_REPO%/files/read-consist-sttm-restart-DDL.sql which contains common DDL for all other such tests.
      Particularly, it contains two TRIGGERS (TLOG_WANT and TLOG_DONE) which are used for logging of planned actions and actual
      results against table TEST. These triggers use AUTONOMOUS transactions in order to have ability to see results in any
      outcome of test.

      Detailed description can be found in "read-consist-sttm-restart-on-update-04.fbt", this test is based on the same ideas:
         * initial script add records with ID = 1...12 and does commit;
         * start locker-1 which catch record with ID = 1 that is to be involved futher in cursor of worker;
         * start worker DML which must change records in descending order of ID, starting with ID=2; worker must write ID = ID * 100 for each row;
         * start locker-2 which changes record with ID=12 by assigning this ID to -12, makes COMMIT and locks this record again (makes UPDATE w/o commit);
         * locker-1 releases record with ID=1, then changes record with ID=11 by assigning this ID to -11, makes COMMIT and locks this record again;
         * locker-2 releases record with ID=-12, then changes record with ID=10 by assigning this ID to -10, makes COMMIT and locks this record again;
         * ... and so on, until number of such actions iterations less 10 or 11 (see below) ...

      Each UPDATE that is performed by lockers (starting from ID=11) produces new ID (-11, -10, -9, ...) that was not present in the scope which worker
      could see before this action. This forces worker to make statement-level restart.

      When number of such new IDs is less than 10 then worker must finish its job successfully.
      But if this number if 11 then worker must raise exception (SQLSTATE = 40001 / deadlock / update conflicts) and rollback all changes.

      Test verifies both cases, using loop with TWO iterations (see 'main_iter' below): first for 10 and second to 11 records that are to be updated.
      After each iteration we do queries to the table TEST and to the view V_WORKER_LOG which contains data generated by trigger TLOG_DONE for logging.

      Test verifies restart number for three modes of WORKER job: UPDATE, MERGE, DELETE and SELECT WITH LOCK (see loop for checked_DML: 'upd', 'mer', 'del', 'lok').
      NOTE-1.
          For 'SELECT WITH LOCK' we must provide that no rows will be returned to client while worker is waiting for records.
          EXECUTE BLOCK with for-select which does nothing is used for this.

      NOTE-2.
          SELECT WITH LOCK does not allow to use VIEW as subject of query (raises "-WITH LOCK can be used only with a single physical table").
          This error is expected in current FB versions thus test does not check results of 'SELECT ... WITH LOCK' against VIEW.

FBTEST:      functional.transactions.read_consist_sttm_restart_max_limit
NOTES:
    [29.07.2022] pzotov
        Checked on 4.0.1.2692 (SS/SC), 5.0.0.591 (SS/SC)
    [27.09.2023] pzotov
        1. Added trace launch and its parsing in order to get number of times when WORKER statement did restart.
           See commits:
           1) FB 4.x (23-JUN-2022, 4.0.2.2782): https://github.com/FirebirdSQL/firebird/commit/95b8623adbf129d0730a50a18b4f1cf9976ac35c
           2) FB 5.x (27-JUN-2022, 5.0.0.555):  https://github.com/FirebirdSQL/firebird/commit/f121cd4a6b40b1639f560c6c38a057c4e68bb3df

           Trace must contain several groups, each with similar lines:
               <timestamp> (<trace_memory_address>) EXECUTE_STATEMENT_RESTART
               {SQL_TO_BE_RESTARTED}
               Restarted <N> time(s)

        2. To prevent raises between concurrent transactions, it is necessary to ensure that code:
               * does not allow LOCKER-2 to start its work until WORKER session will establish connection and - moreover - will actually locks first record 
                 from the scope that is seen by the query that we want to be executed by worker.
               * does not allow LOCKER-1 to do something after LOCKER-2 issued commit (and thus released record): we first have to ensure that this record
                 now is locked by WORKER. The same when record was occupied by LOCKER-2 and then is released: LOCKER-1 must not do smth until WORKER will
                 encounter this record and 'catch' it.
           This is done by calls to function 'wait_for_record_become_locked()' which are performed by separate 'monitoring' connection with starting Tx
           with NO_WAIT mode and catching exception with further parsing. In case when record has been already occupied (by WORKER) this exception will
           have form "deadlock / -update conflicts ... / -concurrent transaction number is <N>". We can then obtain number of this transaction and query
           mon$statements for get MON$SQL_TEXT that is runnig by this Tx. If it contains contains 'special tag' (see variable SQL_TAG_THAT_WE_WAITING_FOR)
           then we can be sure that WORKER really did establish connection and successfully locked row with required ID.

           Table 'TLOG_WANT' (which is fulfilled by trigger TEST_BIUD using in autonomous tx) can NOT be used for detection of moments when WORKER
           actually locks records which he was waiting for: this trigger fires BEFORE actual updating occurs, i.e. when record become seeon by WORKER
           but is still occupied by some LOCKER ("[DOC]: c) engine continue to evaluate remaining records ... and put write locks on it too")

           NB! Worker transaction must running in WAIT mode - in contrary to Tx that we start in our monitoring loop.

        Checked on WI-T6.0.0.55, WI-T5.0.0.1229, WI-V4.0.4.2995 (all SS/CS).

    [01.12.2023] pzotov
    New behaviour of ISQL was introduced after implementation of PR #7868: SET AUTOTERM.
    Since that was implemented, ISQL handles comments (single- and multi-lined) as PART of statement that follows these comments.
    In other words, ISQL in 6.x does not 'swallow' comments and sends them to engine together with statement that follows.
    This means that comment PLUS statement can be 'unexpectedly' seen in the trace log.

    Currently this is not considered as a bug, see note by Adriano: https://groups.google.com/g/firebird-devel/c/AM8vlA3YJws
    Because of this, we must avoid to put comments directly before executing statement. In order to preserve comments, it was decided
    for move them from code that is executing by ISQL (see "Run UPDATE | DELETE | MERGE | SELECT WITH LOCK" and next line).

    Checked on 6.0.0.163, 5.0.0.1284.
"""

import subprocess
import re
from difflib import unified_diff
from pathlib import Path
import time
import datetime as py_dt
import locale

import pytest
from firebird.qa import *
from firebird.driver import tpb, Isolation, TraAccessMode, DatabaseError

substitutions = [ ('=', ''), ('[ \t]+', ' '), ('.* EXECUTE_STATEMENT_RESTART', 'EXECUTE_STATEMENT_RESTART'), ('.*[\\-]?concurrent transaction number is \\d+', 'concurrent transaction number is'), ('.*At\\s+block\\s+line(:)?\\s+\\d+(,)?\\s+col(:)?\\s+\\d+', ''), ('.After\\s+line\\s+\\d+\\s+.*', '')]

db = db_factory()
act = python_act('db', substitutions=substitutions)

MAX_WAIT_FOR_WORKER_START_MS = 10000;
SQL_TAG_THAT_WE_WAITING_FOR = 'SQL_TAG_THAT_WE_WAITING_FOR'
# SQL_TO_BE_RESTARTED -- will be defined inside loop, see below!

fn_worker_sql = temp_file('tmp_worker.sql')
fn_worker_log = temp_file('tmp_worker.log')
fn_worker_err = temp_file('tmp_worker.err')

#-----------------------------------------------------------------------------------------------------------------------------------------------------

def wait_for_record_become_locked(tx_monitoring, cur_monitoring, sql_to_lock_record, SQL_TAG_THAT_WE_WAITING_FOR):

    # ::: NB :::
    # tx_monitoring must work in NOWAIT mode!

    t1=py_dt.datetime.now()
    required_concurrent_found = None
    concurrent_tx_pattern = re.compile('concurrent transaction number is \\d+', re.IGNORECASE)
    while True:
        concurrent_tx_number = None
        concurrent_runsql = ''
        tx_monitoring.begin()
        try:
            cur_monitoring.execute(sql_to_lock_record)
        except DatabaseError as exc:
            # Failed: SQL execution failed with: deadlock
            # -update conflicts with concurrent update
            # -concurrent transaction number is 40
            m = concurrent_tx_pattern.search( str(exc) )
            if m:
                concurrent_tx_number = m.group().split()[-1] # 'concurrent transaction number is 40' ==> '40'
                cur_monitoring.execute( 'select mon$sql_text from mon$statements where mon$transaction_id = ?', (int(concurrent_tx_number),) )
                for r in cur_monitoring:
                    concurrent_runsql = r[0]
                    if SQL_TAG_THAT_WE_WAITING_FOR in concurrent_runsql:
                        required_concurrent_found = 1

            # pytest.fail(f"Can not upd, concurrent TX = {concurrent_tx_number}, sql: {concurrent_runsql}")
        finally:
            tx_monitoring.rollback()
        
        if not required_concurrent_found:
            t2=py_dt.datetime.now()
            d1=t2-t1
            if d1.seconds*1000 + d1.microseconds//1000 >= MAX_WAIT_FOR_WORKER_START_MS:
                break
            else:
                time.sleep(0.2)
        else:
            break

    assert required_concurrent_found, f"Could not find attach that running SQL with tag '{SQL_TAG_THAT_WE_WAITING_FOR}' and locks record for {MAX_WAIT_FOR_WORKER_START_MS} ms. Check query: {sql_to_lock_record}. ABEND."
    return

#-----------------------------------------------------------------------------------------------------------------------------------------------------

@pytest.mark.trace
@pytest.mark.version('>=4.0.2')
def test_1(act: Action, fn_worker_sql: Path, fn_worker_log: Path, fn_worker_err: Path, capsys):

    sql_init = (act.files_dir / 'read-consist-sttm-restart-DDL.sql').read_text()

    for checked_mode in('table', 'view'):
        target_obj = 'test' if checked_mode == 'table' else 'v_test'

        # NB: for 'lok' can not be used with a VIEW, error: "336397326 : WITH LOCK can be used only with a single physical table"
        for checked_DML in ('upd', 'mer', 'del', 'lok') if checked_mode == 'table' else ('upd', 'mer', 'del'):

            ###################################################################################################################
            ### !!! NB !!! DO NOT SPLIT QUERIES ONTO MULTIPLE LINES OTHERWISE CHECK OF TRACE CONTENT WILL FAIL (SEE BELOW)  ###
            ###################################################################################################################
            if checked_DML == 'upd':
                SQL_TO_BE_RESTARTED = f'update /* {SQL_TAG_THAT_WE_WAITING_FOR} */ {target_obj} set id = id * 100 where id <= 2 order by id DESC'
            elif checked_DML == 'mer':
                SQL_TO_BE_RESTARTED = f'merge /* {SQL_TAG_THAT_WE_WAITING_FOR} */ into {target_obj} t using (select x.id from {target_obj} x where x.id <= 2 order by id DESC) s on t.id = s.id when matched then update set t.id = s.id * 100'
            elif checked_DML == 'del':
                SQL_TO_BE_RESTARTED = f'delete /* {SQL_TAG_THAT_WE_WAITING_FOR} */ from {target_obj} where id <= 2 order by id DESC'
            elif checked_DML == 'lok':
                # ::: NB :::
                # We must SUPRESS sending record to client for SELECT WITH LOCK, otherwise error
                # deadlock/update conflist will raise immediately! Because of this, we  enclose
                # such select into execute block which returns nothing:
                #
                SQL_TO_BE_RESTARTED = f'execute block /* {SQL_TAG_THAT_WE_WAITING_FOR} */ as declare c int; begin for select id from {target_obj} where id<=2 order by id DESC with lock into c do begin end end'

            for main_iter in (0,1):

                ###################################################################################
                ###  H O W    M A N Y    R E S T A R T S    W E    W A N T    T O    C H E C K  ###
                ###################################################################################
                ROWS_TO_ADD = 10 + 1 * main_iter

                # Add either 12 or 14 rows, ID = 1,2, ..., 2+ROWS_TO_ADD:
                sql_addi = f'''
                    set term ^;
                    execute block as
                    begin
                        rdb$set_context('USER_SESSION', 'WHO', 'INIT_DATA');
                    end
                    ^
                    set term ;^
                    insert into {target_obj}(id, x) select row_number()over(),row_number()over() from rdb$types rows (2 + {ROWS_TO_ADD}); -- <<< INITIAL DATA
                    commit;
                '''

                act.isql(switches=['-q'], input = ''.join( (sql_init, sql_addi) ) )
                # ::: NOTE ::: We have to immediately quit if any error raised in prepare phase.
                # See also letter from dimitr, 01-feb-2022 14:46
                assert act.stderr == ''
                act.reset()

                # Get Firebird log before test
                fb_log_init = act.get_firebird_log()

                trace_cfg_items = [
                    'time_threshold = 0',
                    'log_errors = true',
                    'log_statement_start = true',
                    'log_statement_finish = true',
                ]

                with act.trace(db_events = trace_cfg_items, encoding=locale.getpreferredencoding()):

                    with act.db.connect() as con_lock_1, act.db.connect() as con_lock_2, act.db.connect() as con_monitoring:

                        tpb_monitoring = tpb(isolation=Isolation.READ_COMMITTED_RECORD_VERSION, lock_timeout=0)
                        tx_monitoring = con_monitoring.transaction_manager(tpb_monitoring)
                        cur_monitoring = tx_monitoring.cursor()
                        
                        locked_rows_map ={} # K = 0 or 1 (locker_1 and locker_2 respectively); V = ID of locked row

                        for i,c in enumerate((con_lock_1,con_lock_2)):
                            sttm = f"execute block as begin rdb$set_context('USER_SESSION', 'WHO', 'LOCKER #{i+1}'); end"
                            c.execute_immediate(sttm)
                        
                        con_monitoring.execute_immediate("execute block as begin rdb$set_context('USER_SESSION', 'WHO', 'MONITOR'); end")

                        #########################
                        ###  L O C K E R - 1  ###
                        #########################
                        locked_rows_map[ 1 ] = 1
                        con_lock_1.execute_immediate( f'update {target_obj} set id=id where id = {locked_rows_map[1]} /* locker-1 */' )

                        # Run UPDATE | DELETE | MERGE | SELECT WITH LOCK  -- see {SQL_TO_BE_RESTARTED}
                        # Every statement ends with 'ORDER BY ID DESC' and must hang because of lockes:

                        worker_sql = f'''
                            set list on;
                            set autoddl off;
                            set term ^;
                            execute block as
                            begin
                                rdb$set_context('USER_SESSION','WHO', 'WORKER');
                            end
                            ^
                            set term ;^
                            commit;
                            SET KEEP_TRAN_PARAMS ON;
                            set transaction read committed read consistency;
                            set list off;
                            set wng off;

                            set count on;
                            set term ^;
                            {SQL_TO_BE_RESTARTED}
                            ^
                            set term ;^

                            -- check results:
                            -- ###############
                            --set echo on;
                            select id from {target_obj} order by id;

                            select v.old_id, v.op, v.snap_no_rank
                            from v_worker_log v
                            where v.op = iif( '{checked_DML}' = 'mer', 'upd', '{checked_DML}'); -- 'UPD' or 'DEL'; for 'SELECT WITH LOCK' no records will be in v_worker_log.
                            --set echo off;

                            --set width who 10;
                            -- DO NOT check this! Values can differ here from one run to another!
                            -- select id, trn, who, old_id, new_id, op, rec_vers, global_cn, snap_no from tlog_done order by id;
                            rollback;

                        '''

                        fn_worker_sql.write_text(worker_sql)

                        with fn_worker_log.open(mode='w') as hang_out, fn_worker_err.open(mode='w') as hang_err:

                            ############################################################################
                            ###  L A U N C H     W O R K E R    U S I N G     I S Q L,   A S Y N C.  ###
                            ############################################################################
                            p_worker = subprocess.Popen([act.vars['isql'], '-i', str(fn_worker_sql),
                                                           '-user', act.db.user,
                                                           '-password', act.db.password,
                                                           '-pag', '999999',
                                                           act.db.dsn
                                                        ],
                                                          stdout = hang_out,
                                                          stderr = hang_err
                                                       )

                            # update ... set id = id * 100 where id <= 2 order by id DESC

                            # NB: when ISQL will establish attach, first record that it must lock is ID = 2 -- see above SQL_TO_BE_RESTARTED
                            # We must to ensure that this (worker) attachment has been really created and LOCKS this record:
                            #
                            wait_for_record_become_locked(tx_monitoring, cur_monitoring, f'update {target_obj} set /* monitor-ini */ id=id where id=2', SQL_TAG_THAT_WE_WAITING_FOR)

                            cur_lock_1 = con_lock_1.cursor()
                            cur_lock_2 = con_lock_2.cursor()
                            sttm = f'update {target_obj} set id = ? where abs( id ) = ?'

                            for i in range(0,ROWS_TO_ADD):
                                v_id = 2 + ROWS_TO_ADD-i
                                if i % 2 == 0:
                                    # main_iter = 0: ROWS_TO_ADD = 10 ==> v_id = 2+10-0 = 12, 2+10-2 = 10, 2+10-4 =  8, 6, 4, 2
                                    # main_iter = 1: ROWS_TO_ADD = 12 ==> v_id = 2+12-0 = 14, 2+10-2 = 12, 2+10-4 = 10, 8, 6, 4
                                    locked_rows_map[ i % 2 ] = -abs( v_id )
                                    cur_lock_2.execute( sttm + f"/* locker-2 lup, ini-upd, i = {i} */", ( -abs( v_id ), v_id, ) )
                                    con_lock_2.commit()
                                    cur_lock_2.execute( sttm + f"/* locker-2 lup, re-upd, i = {i} */", ( -abs( v_id ), v_id, ) )
                                    con_lock_1.commit() # releases ID = locked_rows_map[ 0 ]
                                else:
                                    # main_iter = 0: ROWS_TO_ADD = 10 ==> v_id = 2+10-1 = 11, 2+10-3 =  9, 2+10-5 =  7, 5, 3, 1
                                    # main_iter = 1: ROWS_TO_ADD = 12 ==> v_id = 2+12-1 = 13, 2+10-3 = 11, 2+10-5 =  9, 7, 5, 3
                                    locked_rows_map[ i % 2 ] = -abs( v_id )
                                    cur_lock_1.execute( sttm + f"/* locker-1 lup, ini-upd, i = {i} */", ( -abs( v_id ), v_id, ) )
                                    con_lock_1.commit()
                                    cur_lock_1.execute( sttm + f"/* locker-1 lup, re-upd, i = {i} */", ( -abs( v_id ), v_id, ) )
                                    con_lock_2.commit() # releases ID = locked_rows_map[ 1 ]

                                # NB: when ISQL will establish attach, first record that it must lock is ID = 2 -- see above SQL_TO_BE_RESTARTED
                                # We must to ensure that this (worker) attachment has been really created and LOCKS this record:
                                #
                                wait_for_record_become_locked(tx_monitoring, cur_monitoring, f'update {target_obj} /* monitor lup, i={i} */ set id=id where id = {locked_rows_map[ 1 - (i % 2) ]}', SQL_TAG_THAT_WE_WAITING_FOR)

                            cur_monitoring.execute(f'select count(*) from {target_obj}')
                            for r in cur_monitoring:
                                target_obj_cnt = r[0]
                                #target_obj_cnt = cur_monitoring.fetchall()[0]

                            if ROWS_TO_ADD % 2 == 0:
                                if con_lock_2.is_active():
                                    con_lock_2.commit()
                                con_lock_1.commit()
                            else:
                                if con_lock_1.is_active():
                                    con_lock_1.commit()
                                con_lock_2.commit()

                            # Here we wait for ISQL complete its mission:
                            p_worker.wait()

                    #< with ... con_lock_1, ... con_lock_2



                    #####################################################
                    ###  check content of 'TEST' and 'TLOG*' tables  ###
                    #####################################################

                    print( f'checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = {main_iter}, number of added rows: {ROWS_TO_ADD}' )

                    for g in (fn_worker_log, fn_worker_err):
                        logname = 'STDLOG' if g == fn_worker_log else 'STDERR'
                        with g.open() as f:
                            for line in f:
                                if line.strip():
                                    print( f'checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = {main_iter}, worker {logname}: {line}'  )

                    expected_stdout_worker = f"""
                    """
                    if main_iter == 0:
                        if checked_DML in ('upd', 'mer'):
                            expected_stdout_worker = f"""
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, number of added rows: 10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: Records affected: 12
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:      ID
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: =======
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:   -1200
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:   -1100
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:   -1000
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:    -900
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:    -800
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:    -700
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:    -600
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:    -500
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:    -400
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:    -300
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:     100
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:     200
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: Records affected: 12
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:  OLD_ID OP              SNAP_NO_RANK
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: ======= ====== =====================
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        1
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        2
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                        2
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        3
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                        3
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        4
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                        4
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        5
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                        5
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        6
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                        6
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        7
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                        7
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        8
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                        8
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                        9
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                        9
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                       10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                       10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       2 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:       1 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:      -3 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:      -4 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:      -5 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:      -6 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:      -7 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:      -8 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:      -9 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:     -10 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:     -11 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG:     -12 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: Records affected: 31
                            """
                        elif checked_DML == 'lok':
                            expected_stdout_worker = f"""
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, number of added rows: 10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: ID
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: =======
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -12
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -9
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -8
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -7
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -6
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -5
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -4
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: -3
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: 1
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: 2
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: Records affected: 12
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 0, worker STDLOG: Records affected: 0
                            """
                        elif checked_DML == 'del':
                            expected_stdout_worker = f"""
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, number of added rows: 10
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG: Records affected: 12
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG: Records affected: 0
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:  OLD_ID OP              SNAP_NO_RANK
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG: ======= ====== =====================
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        1
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        2
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                        2
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        3
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                        3
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        4
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                        4
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        5
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                        5
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        6
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                        6
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        7
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                        7
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        8
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                        8
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                        9
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                        9
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                       10
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                       10
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       2 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:       1 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:      -3 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:      -4 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:      -5 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:      -6 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:      -7 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:      -8 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:      -9 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:     -10 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:     -11 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG:     -12 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 0, worker STDLOG: Records affected: 31
                            """
                    else:
                        if checked_DML in ('upd', 'mer'):
                            expected_stdout_worker = f"""
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, number of added rows: 11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: Records affected: 2
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:      ID
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: =======
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:     -13
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:     -12
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:     -11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:     -10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:      -9
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:      -8
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:      -7
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:      -6
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:      -5
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:      -4
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:      -3
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: Records affected: 13
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:  OLD_ID OP              SNAP_NO_RANK
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: ======= ====== =====================
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        1
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        2
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                        2
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        3
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                        3
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        4
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                        4
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        5
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                        5
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        6
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                        6
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        7
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                        7
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        8
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                        8
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                        9
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                        9
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                       10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                       10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       2 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG:       1 UPD                       11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: Records affected: 21
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDERR: Statement failed, SQLSTATE = 40001
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDERR: deadlock
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDERR: -update conflicts with concurrent update
                                concurrent transaction number is
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDERR:
                            """
                        elif checked_DML == 'lok':
                            expected_stdout_worker = f"""
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, number of added rows: 11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: ID
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: =======
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -13
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -12
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -11
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -10
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -9
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -8
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -7
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -6
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -5
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -4
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: -3
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: 1
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: 2
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: Records affected: 13
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDLOG: Records affected: 0
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDERR: Statement failed, SQLSTATE = 40001
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDERR: deadlock
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDERR: -update conflicts with concurrent update
                                concurrent transaction number is
                                checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = 1, worker STDERR:
                            """
                        elif checked_DML == 'del':
                            expected_stdout_worker = f"""
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, number of added rows: 11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG: Records affected: 2
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:      ID
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG: =======
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:     -13
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:     -12
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:     -11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:     -10
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:      -9
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:      -8
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:      -7
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:      -6
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:      -5
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:      -4
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:      -3
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG: Records affected: 13
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:  OLD_ID OP              SNAP_NO_RANK
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG: ======= ====== =====================
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        1
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        2
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                        2
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        3
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                        3
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        4
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                        4
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        5
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                        5
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        6
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                        6
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        7
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                        7
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        8
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                        8
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                        9
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                        9
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                       10
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                       10
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       2 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG:       1 DEL                       11
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDLOG: Records affected: 21
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDERR: Statement failed, SQLSTATE = 40001
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDERR: deadlock
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDERR: -update conflicts with concurrent update
                                concurrent transaction number is
                                checked_mode: {checked_mode}, checked_DML = del, iter = 1, worker STDERR:
                            """

                    act.expected_stdout = expected_stdout_worker
                    act.stdout = capsys.readouterr().out
                    assert act.clean_stdout == act.clean_expected_stdout
                    act.reset()

                #< with act.trace


                #############################################################################################
                ###  check trace content: 'EXECUTE_STATEMENT_RESTART' and 'Restarted 2 time(s)' messages  ###
                #############################################################################################

                allowed_patterns = \
                [
                     '\\)\\s+EXECUTE_STATEMENT_RESTART$'
                    ,re.escape(SQL_TO_BE_RESTARTED)
                    ,'^Restarted \\d+ time\\(s\\)'
                ]
                allowed_patterns = [re.compile(x) for x in allowed_patterns]

                for line in act.trace_log:
                    if line.strip():
                        if act.match_any(line.strip(), allowed_patterns):
                            print(line.strip())

                expected_stdout_trace = f"""
                    {SQL_TO_BE_RESTARTED}
                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 1 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 2 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 3 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 4 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 5 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 6 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 7 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 8 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 9 time(s)

                    EXECUTE_STATEMENT_RESTART
                    {SQL_TO_BE_RESTARTED}
                    Restarted 10 time(s)

                    {SQL_TO_BE_RESTARTED}
                """


                act.expected_stdout = expected_stdout_trace
                act.stdout = capsys.readouterr().out
                assert act.clean_stdout == act.clean_expected_stdout
                act.reset()

                
                ########################################
                ###  check diff in the firebird.log  ###
                ########################################

                # Get Firebird log after test
                fb_log_curr = act.get_firebird_log()

                allowed_patterns = \
                [
                     'Update conflict: unable to get a stable set of rows in the source tables'
                    ,'after 10 attempts of restart.'
                    ,'Query:'
                    ,re.escape(SQL_TO_BE_RESTARTED)
                ]
                allowed_patterns = [re.compile(x) for x in allowed_patterns]

                ##########################################################################
                # !!! NB !!! It is assumed that test query is fully written in ONE line !!
                ##########################################################################
                title_print_flag = 0
                title_message = f'checked_mode: {checked_mode}, checked_DML = {checked_DML}, iter = {main_iter}:' 
                for line in unified_diff(fb_log_init, fb_log_curr):
                    if line.startswith('+') and act.match_any(line, allowed_patterns):
                        if not title_print_flag:
                            print( title_message )
                            title_print_flag = 1
                        print( line.strip()[1:] )
                
                expected_stdout_fblog = f"""
                    {title_message}
                    Update conflict: unable to get a stable set of rows in the source tables
                    after 10 attempts of restart.
                    Query:
                    {SQL_TO_BE_RESTARTED}
                """
                act.expected_stdout = expected_stdout_fblog
                act.stdout = capsys.readouterr().out
                assert act.clean_stdout == act.clean_expected_stdout
                act.reset()

            #< for main_iter in (0,1)
        # < for checked_DML in ('upd', 'mer', 'del', 'lok')
    # < for checked_mode in ('table', 'view')
