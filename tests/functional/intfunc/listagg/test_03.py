#coding:utf-8

"""
ID:          intfunc.listagg.03
ISSUE:       https://github.com/FirebirdSQL/firebird/pull/8689
TITLE:       LISTAGG function: DISTINCT must remove duplicates for varchar data if they are defined using CI/AI collation
DESCRIPTION:
NOTES:
    [20.11.2025] pzotov
    Checked on 6.0.0.1356-df73f92.
"""

import pytest
from firebird.qa import *

db = db_factory(charset = 'utf8')

test_script = """
    set list on;
    set blob all;
    -- alter character set utf8 set default collation unicode_ci_ai;
	create collation estonian_coll_cs_as for utf8 from unicode 'LOCALE=et_EE';
    create collation estonian_coll_ci_ai for utf8 from unicode case insensitive accent insensitive 'LOCALE=et_EE';

    create domain dm_name_cs_as type varchar(1) character set utf8 collate estonian_coll_cs_as;
    create domain dm_name_ci_ai type varchar(1) character set utf8 collate estonian_coll_ci_ai;

    recreate sequence g;
    recreate table test (
       id int
      ,nm_cs_as dm_name_cs_as
      ,nm_ci_ai dm_name_ci_ai
    );
	create table et_alpha(
		id smallint generated by default as identity
		,s dm_name_cs_as
	);
	commit;

	insert into et_alpha(s) values( 'a' );
	insert into et_alpha(s) values( 'A' );
	insert into et_alpha(s) values( 'b' );
	insert into et_alpha(s) values( 'B' );
	insert into et_alpha(s) values( 'c' );
	insert into et_alpha(s) values( 'C' );
	insert into et_alpha(s) values( 'd' );
	insert into et_alpha(s) values( 'D' );
	insert into et_alpha(s) values( 'e' );
	insert into et_alpha(s) values( 'E' );
	insert into et_alpha(s) values( 'f' );
	insert into et_alpha(s) values( 'F' );
	insert into et_alpha(s) values( 'g' );
	insert into et_alpha(s) values( 'G' );
	insert into et_alpha(s) values( 'h' );
	insert into et_alpha(s) values( 'H' );
	insert into et_alpha(s) values( 'i' );
	insert into et_alpha(s) values( 'I' );
	insert into et_alpha(s) values( 'j' );
	insert into et_alpha(s) values( 'J' );
	insert into et_alpha(s) values( 'k' );
	insert into et_alpha(s) values( 'K' );
	insert into et_alpha(s) values( 'l' );
	insert into et_alpha(s) values( 'L' );
	insert into et_alpha(s) values( 'm' );
	insert into et_alpha(s) values( 'M' );
	insert into et_alpha(s) values( 'n' );
	insert into et_alpha(s) values( 'N' );
	insert into et_alpha(s) values( 'o' );
	insert into et_alpha(s) values( 'O' );
	insert into et_alpha(s) values( 'p' );
	insert into et_alpha(s) values( 'P' );
	insert into et_alpha(s) values( 'r' );
	insert into et_alpha(s) values( 'R' );
	insert into et_alpha(s) values( 's' );
	insert into et_alpha(s) values( 'S' );

	insert into et_alpha(s) values( 'š' );
	insert into et_alpha(s) values( 'Š' );
	insert into et_alpha(s) values( 'z' );
	insert into et_alpha(s) values( 'Z' );
	insert into et_alpha(s) values( 'ž' );
	insert into et_alpha(s) values( 'Ž' );
	insert into et_alpha(s) values( 't' );
	insert into et_alpha(s) values( 'T' );
	insert into et_alpha(s) values( 'u' );
	insert into et_alpha(s) values( 'U' );
	insert into et_alpha(s) values( 'v' );
	insert into et_alpha(s) values( 'V' );
	insert into et_alpha(s) values( 'õ' );
	insert into et_alpha(s) values( 'Õ' );
	insert into et_alpha(s) values( 'ä' );
	insert into et_alpha(s) values( 'Ä' );
	insert into et_alpha(s) values( 'ö' );
	insert into et_alpha(s) values( 'Ö' );
	insert into et_alpha(s) values( 'ü' );
	insert into et_alpha(s) values( 'Ü' );
	insert into et_alpha(s) values( 'x' );
	insert into et_alpha(s) values( 'X' );
	insert into et_alpha(s) values( 'y' );
	insert into et_alpha(s) values( 'Y' );

    insert into test(id, nm_cs_as, nm_ci_ai) select row_umber()over(), s, s from et_alpha order by rand();
    commit;

    select
        listagg(distinct nm_cs_as, ':') within group (order by nm_cs_as) as blob_cs_as
       ,listagg(distinct nm_ci_ai, ':') within group (order by nm_ci_ai) as blob_ci_ai
    from test;
"""

act = isql_act('db', test_script, substitutions = [('BLOB_ID.*', '')])

@pytest.mark.version('>=6.0')
def test_1(act: Action):

    expected_stdout = f"""
    """
    act.expected_stdout = expected_stdout
    act.execute(combine_output = True)
    assert act.clean_stdout == act.clean_expected_stdout
